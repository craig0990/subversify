{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"COLOPHON/","title":"Colophon","text":"<p>The hosted documentation for Subversify is produced with Material for MkDocs. MkDocs accepts different Markdown syntax to GitHub, so a small macro in <code>docs/macros.py</code> is used to hide this formatting from GitHub using HTML comments (<code>...</code>). This is only really used in the <code>README.md</code>, which is also the hosted home page. Other docs are standard Markdown.</p>"},{"location":"LICENSE/","title":"MIT License","text":"<p>Copyright (c) 2025 The Subversify Contributors</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \" Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice (including the next paragraph) shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"subversify-core/","title":"@subversify/core","text":"<p>The <code>@subversify/core</code> contains the core functionality for Subversify:</p> <ul> <li>The <code>Module</code> class</li> <li>A <code>Global()</code> decorator and hook implementation</li> <li>A simply <code>AppFactory</code></li> <li>And a work-in-progress <code>inspect()</code> function</li> </ul> <p>If you are familiar with NestJS modules, they are largely similar, but adjusted for Inversify's specific functionality.</p> <p>If you are not familiar with NestJS modules, the Modules section covers some of the basics.</p>"},{"location":"subversify-core/app-factory/","title":"App Factory","text":"<p>Loading Subversify modules is easy using the built-in Inversify <code>loadAsync</code> method, but Subversify also provides a simple <code>AppFactory</code> to help enforce a few small best practices:</p> <ul> <li> The root container should load only one Subversify module root for       consistent binding behaviour</li> <li> The root container should have a <code>defaultScope</code> of <code>Singleton</code></li> <li> The root container should not require manual configuration</li> </ul> <p>The <code>AppFactory</code> exposes a <code>create</code> factory method that only accepts a single module, and resolves to a <code>Promise</code> with the configured root container:</p> index.tsapp.ts <pre><code>import { AppFactory } from \"@subversify/core\";\nimport { App } from \"./app\";\nimport { AppModule } from \"./app.module\";\n\nAppFactory.create(AppModule).then((container) =&gt; {\n  const app = container.resolve(App);\n});\n</code></pre> <pre><code>export class App {\n  constructor(appService: AppService) {\n    console.log(appService);\n  }\n}\n</code></pre>"},{"location":"subversify-core/app-factory/#options","title":"Options","text":"<p>To support progressively migrating to modules in existing applications, the root container can be provided in the optional <code>options</code> argument:</p> <pre><code>AppFactory.create(AppModule, {\n  container: existingContainer,\n}).then(/** ... */);\n</code></pre> <p>Caution</p> <p>For application root containers with a <code>defaultScope</code> of <code>Transient</code>, this \"should\" be fine as all modules are <code>Singleton</code> by default, although this has not been tested extensively.</p>"},{"location":"subversify-core/bindings/","title":"Bindings","text":"<p>Bindings are used in the <code>bindings</code> and <code>exposes</code> properties of a module.</p> <p>Subversify supports two ways of declaring a binding; either with a direct reference to a class constructor, or with a full binding definition.</p>"},{"location":"subversify-core/bindings/#binding-definition","title":"Binding Definition","text":"<p>A binding definition is of the form <code>{ identifier, prepare }</code>. Both fields are required.</p>"},{"location":"subversify-core/bindings/#identifier","title":"<code>identifier</code>","text":"<p>An identifier that will be used to bind to the module container. This is usually a reference to a class constructor, but it can be any valid Inversify service identifier such as a string, symbol, or <code>Function</code> reference</p>"},{"location":"subversify-core/bindings/#preparebind","title":"<code>prepare(bind)</code>","text":"<p>A preparation function, where you can define how to bind your identifier to the module container. Subversify handles the initial bind call for you.</p> <p>The function will receive a <code>bind</code> parameter, which is the result of a call to the <code>moduleContainer.bind(identifier)</code> function.</p> <p>You can chain new fluent calls off this just like ordinary Inversify bindings, such as a <code>bind.toDynamicValue(() =&gt; /* ... */)</code>, etc.</p>"},{"location":"subversify-core/bindings/#constructor-shorthand","title":"Constructor Shorthand","text":"<p>When you define a binding as a reference to a class constructor, Subversify expands this to a default binding definition. For example, <code>MyService</code> becomes:</p> <pre><code>import type { Binding } from \"@subversify/core\";\n\nclass MyService {}\n\nconst binding: Binding = {\n  identifier: MyService,\n  prepare: (bind) =&gt; bind.toSelf()\n}\n</code></pre> <p>Which is equivalent to: <code>moduleContainer.bind(MyService).toSelf()</code></p>"},{"location":"subversify-core/bindings/#exposed-bindings","title":"Exposed Bindings","text":"<p>Exposed bindings have the same type signature, but they only use the <code>identifier</code>. The <code>prepare</code> step is unused and is not executed.</p> <p>When a module is loaded into another container (via module <code>imports</code> or a manual container call to <code>loadAsync</code>) it will be bound as a dynamic value, proxying through to the imported module container. Conceptually, it looks like this:</p> <pre><code>import { Container, type interfaces } from \"inversify\";\n\nexport class Module {\n  registry(bind: interfaces.Bind) {\n    const moduleContainer = new Container();\n    this.exposes.forEach((exposedBinding) =&gt; {\n        // Bind function is provided by the target module/container being imported into\n        bind(exposedBinding.identifier).toDynamicValue(() =&gt; moduleContainer.get(exposedBinding.identifier));\n    });\n  }\n}\n</code></pre> <p>This works because module containers have a <code>defaultScope</code> of <code>Singleton</code>, which is discussed further in the Modules section of the documentation.</p>"},{"location":"subversify-core/hooks/","title":"Hooks","text":"<p>Warning</p> <p>Hooks are intended as both an extension mechanism and an escape hatch. Being able to execute hooks is a supported feature, but making sure your hooks behave correctly in different scenarios is up to you.</p> <p>A module root may define an additional <code>hooks</code> property, which executes an array of middleware functions when a module is activated (by loading it into a container or into another module).</p> <p>The hooks defined on the module root will be executed before any binding takes place, and any imported module will also be passed through the same hook functions (also before any binding takes place in their respective module containers).</p> <p>Note</p> <p>Even though it's syntactically valid to define hooks in any module, only the module root that is loaded into an Inversify container will have it's hooks executed.</p>"},{"location":"subversify-core/hooks/#hook-functions","title":"Hook Functions","text":"<p>Hooks receive a reference to the module instance, and a reference to the module container.</p> <p>Accessing the module instance means you can access either core properties like <code>imports</code>, <code>bindings</code>, or <code>exposes</code>, or define your own new properties for use.</p> <p>See the Hooks type signature or the Subversify source code for further details.</p> <p>For example, <code>@subversify/express-utils</code> reads a <code>controllers</code> property so that modules can define global controllers linked to module-level dependencies.</p> <p>You can also access the constructor through the instance (<code>moduleDefinition.constructor</code>) which makes hooks a good way to read and act on metadata defined by decorators. This is how Global Modules are implemented internally.</p>"},{"location":"subversify-core/hooks/#type-safety","title":"Type Safety","text":"<p>As discussed in Module Patterns, you can define your modules as classes using various JavaScript/TypeScript syntax features.</p> <p>Public class fields can have some non-obvious gotchas when it comes to typing.</p> <p>The short version is there are three recommendations for providing types for your hooks and module graphs using hooks:</p>"},{"location":"subversify-core/hooks/#define-a-type-for-your-hooks","title":"Define a Type for your Hooks","text":"<p>Define an object type that defines any extra properties your hook supports. Using <code>With${PropName}</code> is a suggested naming convention:</p> <pre><code>type Constructor&lt;T = unknown&gt; = { new(...args: any[] ): T }\n\nexport type WithControllers = {\n  controllers?: Constructor[]\n}\n</code></pre>"},{"location":"subversify-core/hooks/#use-implements-for-static-modules","title":"Use <code>implements</code> for static modules","text":"<p>If you are using public class fields and don't need a factory for your module, use <code>implements</code>:</p> <pre><code>import { Module } from \"@subversify/core\";\nimport type { WithControllers } from \"@subversify/express-utils\";\n\nexport class UserModule extends Module implements WithControllers {\n  controllers: [123]; // will now flag a type error\n}\n</code></pre>"},{"location":"subversify-core/hooks/#use-generics-for-modules-created-with-factories","title":"Use Generics for modules created with factories","text":"<p>If your module is instantiated by a factory through it's constructor, use the generic parameter of <code>Module</code> to type the constructor arguments:</p> <pre><code>import { Module } from \"@subversify/core\";\nimport type { WithControllers } from \"@subversify/express-utils\";\nclass UserModule extends Module&lt;WithControllers&gt; {}\n\nconst UserModuleFactory = {\n  register(options?: any) {\n    return new UserModule({\n      controllers: [123], // will now flag a type error\n      imports: [],\n      bindings: [],\n      exposes: []\n    })\n  }\n}\n\nexport { UserModuleFactory as UserModule };\n</code></pre>"},{"location":"subversify-core/inspecting-modules/","title":"Inspecting Modules","text":"<p>Warning</p> <p>The <code>inspect</code> API is unstable, and is a work in progress</p> <p>Subversify exports an <code>inspect</code> function, which accepts an instantiated module root, and prints a nested object representation of the module graph.</p> <pre><code>import { inspect } from \"@subversify/core\";\nimport { AppModule } from \"./app.module\";\n\nconsole.log(inspect(new AppModule()));\n</code></pre>"},{"location":"subversify-core/modules/","title":"Modules","text":"<p>The home page examples are mostly plug and play, and ideally, Subversify behaves as you would expect in most cases. For some use cases however, it can be helpful to understand some of the internals at a high level.</p>"},{"location":"subversify-core/modules/#module-lifecyle","title":"Module Lifecyle","text":"<p>Modules in Subversify are just classes that implement the Inversify <code>AsyncContainerModule</code> interface, wich means they can be loaded with the Inversify <code>loadAsync</code> container method.</p> <p>So a module is a <code>class</code>, which will be instantiated, and loaded into a container.</p> <p>These three stages in a module lifecycle are important to understanding the more advanced use cases discussed in this section, so let's introduce some terms:</p>"},{"location":"subversify-core/modules/#module-definition","title":"Module Definition","text":"<p>A module definition is your <code>class</code> definition. It represents the structure of the module, which defines how it will behave when instantiated and loaded.</p> <p>At this stage, the module is simply a blueprint with no execution or state.</p> <pre><code>import { Module } from \"@subversify/core\";\n\nexport class AppModule extends Module {\n  imports = [];\n  bindings = [];\n  exposes = [];\n}\n</code></pre>"},{"location":"subversify-core/modules/#module-instance","title":"Module Instance","text":"<p>A module instance is created by instantiating the <code>class</code>, which means we now have an instance of an <code>AsyncContainerModule</code>.</p> <p>You could think of this as an instantiated factory\u2014it has a copy of the module definition (<code>imports</code>, <code>bindings</code>, and <code>exposes</code> properties) but hasn\u2019t yet created an internal container or performed any bindings.</p> <p>This instance can be loaded one or more times into a \"parent\" container. The act of loading is what activates the module.</p> <pre><code>const appModule = new AppModule();\n</code></pre>"},{"location":"subversify-core/modules/#activated-module","title":"Activated Module","text":"<p>An activated module is the result of loading a module instance into a container. This is when the module creates a private module container, registers it's internal bindings, and exposes some of those bindings to the loading container. </p> <pre><code>import { Container } from \"inversify\";\nimport { AppModule } from \"./app.module\";\n\ncontainer.loadAsync(new AppModule()).then(() =&gt; {\n  /* Exposed bindings now registered in `container` */\n});\n</code></pre> <p>Note</p> <p>You don't get access to an activated module's module container, by design. It is not bound or returned anywhere. If you need to extend Subversify's behaviour, you can consider Hooks.</p>"},{"location":"subversify-core/modules/#module-container","title":"Module Container","text":"<p>The module container is what actually holds your bindings\u2014as described earlier, it is created when a module is loaded into a \"parent\" container <sup>3</sup>.</p>"},{"location":"subversify-core/modules/#module-container-default-scope","title":"Module Container Default Scope","text":"<p>The module container has a <code>defaultScope</code> of <code>Singleton</code>.</p> <p>Any bindings defined in your module are therefore also singletons, unless you specify a full binding definition and customize the scope in the <code>prepare()</code> function.</p>"},{"location":"subversify-core/modules/#module-roots","title":"Module Roots","text":"<p>The first time a module is loaded into a container - either into your application container with <code>loadAsync</code>, or into another module via <code>imports</code> - it also becomes a module root <sup>1</sup>.</p> <p>A module root defines a \"module registry\", which is shared by all the modules imported from this root. The module registry ensures that any module is only ever instantiated once within a given module graph (effectively: modules are also singletons, by default).</p> <p>Consider the following module graph, where <code>AppModule</code> forms the module root:</p> <pre><code>flowchart TD\n  app[AppModule]\n  user[UserModule]\n  article[ArticleModule]\n  logger[LoggerModule]\n\n  app --&gt; user\n  app --&gt; article\n\n  user --&gt; logger\n  article --&gt; logger</code></pre> Logger is depended on multiple times <p>The <code>App</code> loads the <code>User</code> and <code>Article</code> modules. Both <code>User</code> and <code>Article</code> load the <code>Logger</code> Module.</p> <p>If modules were registered without checking for previous instances, <code>User</code> would instantiate and load <code>Logger</code> once (which activates the module and creates a module container), and then <code>Article</code> would load instantiate and load <code>Logger</code> again.</p> <p>The second <code>Logger</code> module instance would not be \"activated\", and would result in a second module container being created, which would mean duplicate bindings, and duplicate services.</p> <p>Warning</p> <p>Module singleton behaviour means you should only have one module root per root container\u2014loading multiple modules into a root container creates multiple module roots, is not explicitly supported, and may be harder to debug.</p>"},{"location":"subversify-core/modules/#module-factories","title":"Module Factories<sup>2</sup>","text":"<p>For a given module root, additional modules imported using their class constructor as a reference will be singletons.</p> <p>Some use cases require more flexibility\u2014usually infrastructure concerns like database integrations, caches, and so on.</p> <p>Since Subversify modules are just classes, it's possible to use normal factory patterns to create different configurations of the same module.</p> <p>You can implement your factories any way you want, but the NestJS Community Guidelines define a very reasonable convention of <code>register</code>, <code>forRoot</code>, <code>forFeature</code>, etc, so we'll use that approach here:</p> <pre><code>import { Module } from \"@subversify/core\";\n\n// Define our module extending from the Module class\nclass SomeModule extends Module {}\n\n// Define our static factory methods as a standalone object\nconst SomeModuleFactory = {\n  register(config: any) {\n    return new SomeModule({\n      imports: [/* ... */],\n      bindings: [/* ... */],\n      exposes: [/* ... */],\n    })\n  }\n}\n\n// Export our factory and rename it for consistency\nexport { SomeModuleFactory as SomeModule };\n</code></pre> <p>Why not use static class methods?</p> <p>:    You can, if you really prefer, but the class constructor will exposed to      other modules, and other modules may accidentally use the constructor in      <code>imports</code> instead of the static methods:</p> <pre><code> ```typescript\n class SomeModule extends Module {\n   static register() {\n     return new this({ /* ... */ });\n   }\n }\n\n class OtherModule extends Module {\n   /**\n    * No error, but OtherModule will instantiate an empty module, which is\n    * probably not what you want\n    */\n   imports = [SomeModule];\n }  \n ```\n</code></pre> <p>Info</p> <p>It is not possible to access the container directly in factory methods, because they are being executed \"outside\" the Subversify registration loop.</p> <p>It is possible to access the container when binding in the <code>prepare</code> function of a binding definition, however, via the default Inversify <code>context</code> parameter:</p> <pre><code>{\n  identifier: \"SOME_IDENTIFIER\",\n  prepare(bind) {\n    return bind.toDynamicValue((context)) =&gt; {\n      return new SomeClass(context.container.get(\"OTHER_DEPENDENCY_IDENTIFIER\");\n    }\n  }\n}\n</code></pre> <p>This is how the example Todo app retrieves a data source when binding <code>forFeature</code> repositories:</p> <pre><code>const bindings: Binding[] = entities.map((entity) =&gt; ({\n  identifier: RepositoryIdentifier(entity, dataSource),\n  prepare(bind) {\n    bind\n      .toDynamicValue((context) =&gt;\n        context.container.get&lt;DataSource&gt;(DataSourceIdentifier(dataSource)).getRepository(entity),\n      )\n      .inSingletonScope();\n  },\n}));\n</code></pre>"},{"location":"subversify-core/modules/#global-modules","title":"Global Modules","text":"<p>Importing the same core modules throughout your application can be cumbersome for common functionality such as database or logging services.</p> <p>Subversify provides a <code>@Global</code> decorator to mark a module as global, and a Hook to opt-in to this behaviour in a given module root.</p> <p>For example, we can define a global <code>Logger</code> module providing a service:</p> logger.module.ts<pre><code>import { Global, Module } from \"@subversify/core\";\nimport { LoggerService } from \"./logger.service\";\n\n@Global()\nexport class LoggerModule extends Module {\n  bindings = [LoggerService];\n  exposes = [LoggerService];\n}\n</code></pre> <p>And we can import this in our module root, and apply the <code>GlobalHook</code>:</p> app.module.ts<pre><code>import { GlobalHook, Module } from \"@subversify/core\";\nimport { LoggerModule } from \"./logger/logger.module\";\nimport { UserModule } from \"./user/user.module\";\nimport { UserService } from \"./user/user.service\";\n\nexport class AppModule extends Module {\n  hooks = [GlobalHook()];\n  imports = [LoggerModule, UserModule];\n  exposes = [UserService];\n}\n</code></pre> <p>And then we can depend on our logger services without explicitly importing them in other modules:</p> \"user.service.ts<pre><code>import { injectable } from \"inversify\";\nimport { LoggerService } from \"../logger/logger.service\";\n\n@injectable()\nexport class UserService {\n  constructor(logger: LoggerService) {\n    logger.log(this.constructor.name, 'initialized with', logger);\n  }\n}\n</code></pre> <p>Warning</p> <p>Global modules can introduce coupling and portability problems in your application's modules</p>"},{"location":"subversify-core/modules/#patterns","title":"Patterns","text":"<p>As repeated often throughout this documentation, modules are just classes, which provides for a lot of flexibility in how to define them. This flexibility may not always be a good thing, but you are free to choose pattern(s) that work for you.</p> <p>This documentation uses public class fields as a shorthand:</p> <pre><code>class UserModule extends Module  {\n  imports = [];\n  bindings = [];\n  exposes = []\n}\n</code></pre> <p>You could also define a module by overriding the constructor and calling <code>super</code>:</p> <pre><code>class UserModule extends Module {\n  constructor() {\n    super({\n      imports: [],\n      bindings: [],\n      exposes: []\n    })\n  }\n}\n</code></pre> <p>You could use static class methods, but as noted in Module Factories, this potentially creates confusion if a user references the class constructor instead of calling the static method:</p> <pre><code>/**\n * WARNING: UserModule is still a valid module, but it will have no\n * bindings / exposed bindings\n */\nclass UserModule extends Module {\n  static register(options?: any) {\n    return new this({\n      imports: [\"...\"],\n      bindings: [\"...\"],\n      exposes: [\"...\"]\n    });\n  }\n}\n</code></pre> <p>If factory functions are needed, it is suggested to separate the <code>Module</code> from the factory:</p> <pre><code>class UserModule extends Module {}\n\nconst UserModuleFactory = {\n  register(options?: any) {\n    return new UserModule({\n      imports: [],\n      bindings: [],\n      exposes: []\n    })\n  }\n}\n\n// Optionally rename the export for consistent naming with static modules\nexport { UserModuleFactory as UserModule };\n</code></pre> <p>In simple use cases, these differences aren't very important. They become more important if you are using Hooks and are aiming for stricter type safety (largely because public class fields cannot be generic in TypeScript).</p> <ol> <li> <p>Module Roots are just a concept; there is no direct reference to the term in the source code\u00a0\u21a9</p> </li> <li> <p>These are called Dynamic Modules in NestJS\u00a0\u21a9</p> </li> <li> <p>Techically, the module container is created the first time a module is registered into a parent container. See Module Roots for more in depth details\u00a0\u21a9</p> </li> </ol>"},{"location":"subversify-express-utils/","title":"@subversify/express-utils","text":"<p>The <code>@subversify/express-utils</code> package provides a customized decorator and module hook for working with <code>inversify-express-utils</code> controllers in a Subversify application.</p> <p>It is generally intended for working with existing <code>inversify-express-utils</code> controllers as part of a progressive modularisation strategy, to overcome the global registration approach of <code>inversify-express-utils</code>. Suitable alternatives\u2014if any\u2014depend on your specific situation too much for any recommendations to be made here.</p>"},{"location":"subversify-express-utils/#installation","title":"Installation","text":"<pre><code>$ npm install --save @subversify/express-utils\n</code></pre>"},{"location":"subversify-express-utils/#usage","title":"Usage","text":""},{"location":"subversify-express-utils/#definingmigrating-controllers","title":"Defining/Migrating Controllers","text":"<p>When creating a new controller or migrating an existing controller within a Subversify module, use this package's <code>@controller</code> decorator instead of the one exported by <code>inversify-express-utils</code>.</p> <p>Other decorators such as <code>httpGet</code> etc. should continue to be imported from <code>inversify-express-utils</code>.</p> user.controller.ts<pre><code>import { controller } from \"@subversify/express-utils\";\nimport { httpGet, response } from \"inversify-express-utils\";\n\n@controller(\"/users\")\nexport class UserController { \n  @httpGet(\"/\")\n  public index(@response() res: express.Response) {\n    res.send(\"OK\");\n  }\n}\n</code></pre> <p>Internally, the <code>@controller</code> decorator proxies all arguments to the <code>@controller</code> decorator from <code>inversify-express-utils</code>, but removes the automatic global registration of the controller.</p>"},{"location":"subversify-express-utils/#registering-controllers","title":"Registering Controllers","text":"<p>In your application module root, register the <code>Controllers</code> hook from this package. The hook is a factory function, with zero parameters:</p> app.module.ts<pre><code>import { Module } from \"@subversify/core\";\nimport { ControllersHook } from \"@subversify/express-utils\";\n\nexport class AppModule {\n  hooks = [ControllersHook()];\n  /* imports, bindings, etc. */\n}\n</code></pre> <p>Now, in your module(s) you can register your controller by explicitly including it in a <code>controllers</code> class property. If you do not include it in a <code>controllers</code> property, it will not be registered in the Inversify Express Server.</p> <p>For static modules, you can implement <code>WithControllers</code> for better type safety:</p> user.module.ts<pre><code>import { Module } from \"@subversify/core\";\nimport { WithControllers } from \"@subversify/express-utils\";\n\nexport class UserModule extends Module implements WithControllers {\n  controllers = [UserController];\n}\n</code></pre> <p>For module factories, you will need to use <code>WithControllers</code> as a generic type parameter to tell the base <code>Module</code> constructor about the new <code>controllers</code> property:</p> user.module.ts<pre><code>import { Module } from \"@subversify/core\";\nimport { WithControllers } from \"@subversify/express-utils\";\n\nclass UserModule extends Module&lt;WithControllers&gt; {}\n\nconst UserModuleFactory = {\n  static register(options?: any) {\n    return new UserModule({\n      controllers: [UserController]\n    });\n  }\n}\n\nexport { UserModuleFactory as UserModule }\n</code></pre> <p>That's it. Building your Inversify Express Server is the same as the <code>inversify-express-utils</code> package documentation.</p>"},{"location":"subversify-express-utils/#gotchas","title":"Gotchas","text":"<p>Moving your controller into a Subversify module means it can only access dependencies defined by that module, it's imports, or global module bindings.</p> <p>If your controller currently depends on services defined in your root container, some work may be required to refactor those into modules that can be imported.</p>"}]}